import { execSync, spawn } from "child_process";
import * as fsPromises from "fs/promises";
import * as fsNode from "fs";
import * as fs from "fs-extra";
import * as path from "path";
import {
  S3Client,
  PutObjectCommand,
  ListObjectsV2Command,
  DeleteObjectsCommand,
} from "@aws-sdk/client-s3";
import {
  AppSyncClient,
  EvaluateCodeCommand,
  EvaluateCodeCommandInput,
} from "@aws-sdk/client-appsync";
import * as crypto from "crypto";
import { logger, setLogFile, closeLogFile } from "./logger";

/** Error with message and optional stdout/stderr from exec commands */
interface ExecError {
  message?: string;
  stdout?: Buffer | string;
  stderr?: Buffer | string;
  stack?: string;
}

export interface ResolverCompilerOptions {
  logger: typeof logger;
  baseResolverDir: string;
  s3KeyPrefix: string;
  stage: string;
  s3BucketName: string;
  region: string;
  resolverFiles: string[];
  debugMode?: boolean;
}

class ResolverCompiler {
  private logger: typeof logger;
  private baseResolverDir: string;
  private buildDir: string;
  private s3KeyPrefix: string;
  private stage: string;
  private resolverFiles: string[];
  private s3BucketName: string;
  private s3Client: S3Client;
  private appSyncClient: AppSyncClient;
  private region: string;
  private debugMode: boolean;

  constructor(options: ResolverCompilerOptions) {
    this.logger = options.logger;
    this.baseResolverDir = options.baseResolverDir;
    this.s3KeyPrefix = options.s3KeyPrefix;
    this.stage = options.stage;
    this.s3BucketName = options.s3BucketName;
    this.region = options.region;
    this.resolverFiles = options.resolverFiles;
    this.s3Client = new S3Client({ region: this.region });
    this.appSyncClient = new AppSyncClient({ region: this.region });
    this.debugMode = options.debugMode || false;

    const projectRoot = this.getProjectRoot();
    this.buildDir = path.join(projectRoot, ".cache", "deploy", "resolvers");
  }

  private getProjectRoot(): string {
    // import.meta.dirname is quiz-app/deploy/utils, go up 2 levels to project root
    return path.join(import.meta.dirname, "..", "..");
  }

  private async recursiveCopy(src: string, dest: string): Promise<void> {
    await fsPromises.mkdir(dest, { recursive: true });
    const entries = await fsPromises.readdir(src, { withFileTypes: true });
    for (const entry of entries) {
      const srcPath = path.join(src, entry.name);
      const destPath = path.join(dest, entry.name);
      if (entry.isDirectory()) {
        await this.recursiveCopy(srcPath, destPath);
      } else {
        await fsPromises.copyFile(srcPath, destPath);
      }
    }
  }

  private addHeaderToJs(jsContent: string, sourceFilePath: string): string {
    const relativeSourcePath = path.relative(process.cwd(), sourceFilePath);
    const header = `
/**********************************************************************************************************************
 *                                                                                                                    *
 *  DO NOT EDIT THIS FILE.                                                                                            *
 *                                                                                                                    *
 *  This file is automatically generated by the build process.                                                        *
 *                                                                                                                    *
 *  Source file: ${relativeSourcePath}
 *                                                                                                                    *
 **********************************************************************************************************************/
    `;
    return header.trim() + "\n\n" + jsContent;
  }

  private async uploadToS3(
    s3Key: string,
    content: string,
    contentType: string,
  ): Promise<void> {
    await this.s3Client.send(
      new PutObjectCommand({
        Bucket: this.s3BucketName,
        Key: s3Key,
        Body: content,
        ContentType: contentType,
      }),
    );
  }

  /**
   * Validates resolver code using AppSync's evaluate-code API.
   */
  private async validateWithAppSync(
    code: string,
    resolverName: string,
  ): Promise<boolean> {
    const isPipeline = resolverName.includes(".pipeline.");
    if (isPipeline) {
      logger.debug(`Skipping AppSync validation for pipeline resolver: ${resolverName}`);
      return true;
    }

    const hasRequest = code.includes("export function request") || code.includes("export { request");
    const hasResponse = code.includes("export function response") || code.includes("export { response");

    const minimalContext = JSON.stringify({
      arguments: {},
      args: {},
      identity: {
        sub: "test-user",
        claims: { "cognito:groups": [] },
        groups: [],
      },
      source: {},
      result: {},
      prev: { result: {} },
      stash: {},
      request: { headers: {} },
    });

    try {
      if (hasRequest) {
        const requestInput: EvaluateCodeCommandInput = {
          runtime: { name: "APPSYNC_JS", runtimeVersion: "1.0.0" },
          code,
          context: minimalContext,
          function: "request",
        };
        const requestResult = await this.appSyncClient.send(new EvaluateCodeCommand(requestInput));
        if (requestResult.error) {
          throw new Error(`AppSync validation failed for ${resolverName} (request): ${requestResult.error.message}`);
        }
      }

      if (hasResponse) {
        const responseInput: EvaluateCodeCommandInput = {
          runtime: { name: "APPSYNC_JS", runtimeVersion: "1.0.0" },
          code,
          context: minimalContext,
          function: "response",
        };
        const responseResult = await this.appSyncClient.send(new EvaluateCodeCommand(responseInput));
        if (responseResult.error) {
          throw new Error(`AppSync validation failed for ${resolverName} (response): ${responseResult.error.message}`);
        }
      }

      logger.debug(`âœ“ AppSync validation passed: ${resolverName}`);
      return true;
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : String(error);

      // These lint rules are outdated - arrow functions ARE supported since Feb 2023
      const outdatedLintRules = ["@aws-appsync/no-function-passing", "ArrowFunction"];
      const isOutdatedLintRule = outdatedLintRules.some(rule => errorMessage.includes(rule));
      if (isOutdatedLintRule) {
        logger.debug(`AppSync validation for ${resolverName} has outdated lint warning (ignoring): ${errorMessage}`);
        return true;
      }

      // Truly unsupported features
      const trulyUnsupportedPatterns = [
        "@aws-appsync/no-for",
        "@aws-appsync/no-while",
        "@aws-appsync/no-disallowed-unary-operators",
      ];
      const isTrulyUnsupported = trulyUnsupportedPatterns.some(pattern => errorMessage.includes(pattern));

      if (isTrulyUnsupported || errorMessage.includes("code contains one or more errors") || errorMessage.includes("SyntaxError")) {
        throw new Error(`AppSync code validation failed for ${resolverName}: ${errorMessage}`);
      }

      // Runtime errors during evaluation are OK - the code syntax is valid
      logger.debug(`AppSync validation for ${resolverName} had runtime error (code is valid): ${errorMessage}`);
      return true;
    }
  }

  /**
   * Cleans up old resolver deployments from S3, keeping only the most recent ones
   */
  private async cleanupOldS3Resolvers(keepCount: number = 5): Promise<void> {
    try {
      logger.debug(`Checking for old resolver deployments to clean up in S3...`);
      const prefix = path.posix.join(this.s3KeyPrefix, this.stage) + "/";

      const listCommand = new ListObjectsV2Command({
        Bucket: this.s3BucketName,
        Prefix: prefix,
        Delimiter: "/",
      });

      const response = await this.s3Client.send(listCommand);

      if (!response.CommonPrefixes || response.CommonPrefixes.length === 0) {
        logger.debug(`No previous resolver deployments found in S3`);
        return;
      }

      const hashDirs: { prefix: string; hash: string }[] = [];
      for (const commonPrefix of response.CommonPrefixes) {
        if (commonPrefix.Prefix) {
          const hash = commonPrefix.Prefix.replace(prefix, "").replace("/", "");
          if (hash) {
            hashDirs.push({ prefix: commonPrefix.Prefix, hash });
          }
        }
      }

      const hashDirsWithTime: { prefix: string; hash: string; lastModified: Date }[] = [];
      for (const hashDir of hashDirs) {
        const listObjectsCommand = new ListObjectsV2Command({
          Bucket: this.s3BucketName,
          Prefix: hashDir.prefix,
          MaxKeys: 1,
        });
        const objectsResponse = await this.s3Client.send(listObjectsCommand);
        if (objectsResponse.Contents && objectsResponse.Contents.length > 0) {
          const lastModified = objectsResponse.Contents[0].LastModified || new Date(0);
          hashDirsWithTime.push({ ...hashDir, lastModified });
        }
      }

      hashDirsWithTime.sort((a, b) => b.lastModified.getTime() - a.lastModified.getTime());
      const deploymentsToDelete = hashDirsWithTime.slice(keepCount);

      if (deploymentsToDelete.length === 0) {
        logger.debug(`Found ${hashDirsWithTime.length} resolver deployment(s), keeping all (limit: ${keepCount})`);
        return;
      }

      logger.info(`Found ${hashDirsWithTime.length} resolver deployments. Keeping ${Math.min(keepCount, hashDirsWithTime.length)}, deleting ${deploymentsToDelete.length} old deployment(s)...`);

      for (const deployment of deploymentsToDelete) {
        await this.deleteS3Prefix(deployment.prefix);
        logger.success(`âœ“ Deleted old resolver deployment: ${deployment.hash}`);
      }

      logger.success(`Cleaned up ${deploymentsToDelete.length} old resolver deployment(s) from S3`);
    } catch (error: unknown) {
      const err = error as ExecError;
      logger.warning(`Failed to cleanup old S3 resolvers (continuing): ${err.message || String(error)}`);
    }
  }

  private async deleteS3Prefix(prefix: string): Promise<void> {
    let continuationToken: string | undefined;

    do {
      const listCommand = new ListObjectsV2Command({
        Bucket: this.s3BucketName,
        Prefix: prefix,
        ContinuationToken: continuationToken,
      });

      const response = await this.s3Client.send(listCommand);

      if (response.Contents && response.Contents.length > 0) {
        const objectsToDelete = response.Contents.map((obj) => ({ Key: obj.Key! }));
        const deleteCommand = new DeleteObjectsCommand({
          Bucket: this.s3BucketName,
          Delete: { Objects: objectsToDelete, Quiet: true },
        });
        await this.s3Client.send(deleteCommand);
        logger.debug(`Deleted ${objectsToDelete.length} objects from ${prefix}`);
      }

      continuationToken = response.NextContinuationToken;
    } while (continuationToken);
  }

  public async compileAndUploadResolvers(): Promise<string> {
    const projectRoot = this.getProjectRoot();

    const stopSpinner = logger.infoWithSpinner("Starting resolver compilation and upload...");
    try {
      await this.setupBuildDirectory();
    } finally {
      stopSpinner();
    }

    const totalFiles = this.resolverFiles.length;
    logger.debug(`Processing ${totalFiles} resolver files...`);

    const localSavePathBase = path.join(projectRoot, ".cache", "deploy", "resolvers");

    const failedResolvers: { file: string; error: string }[] = [];
    const compiledFilesRelative: string[] = [];
    const resolverSourcePaths: { relative: string; absolute: string }[] = [];

    // Phase 1: Prepare all source files
    logger.debug("Phase 1: Preparing modified source files...");
    for (let index = 0; index < totalFiles; index++) {
      const resolverFileRelativePath = this.resolverFiles[index];
      logger.debug(`[${index + 1}/${totalFiles}] Preparing resolver: ${resolverFileRelativePath}...`);

      const resolverAbsolutePath = path.join(this.baseResolverDir, resolverFileRelativePath);

      try {
        const originalResolverSourceCode = await fsPromises.readFile(resolverAbsolutePath, "utf-8");
        await this.prepareSourceFile(originalResolverSourceCode, resolverAbsolutePath);
        resolverSourcePaths.push({ relative: resolverFileRelativePath, absolute: resolverAbsolutePath });
      } catch (error: unknown) {
        const err = error as ExecError;
        logger.error(`Failed to prepare resolver ${resolverFileRelativePath}: ${err.message || String(error)}`);
        failedResolvers.push({ file: resolverFileRelativePath, error: err.message || String(error) });
      }
    }

    // Phase 2: Compile all prepared source files
    logger.debug(`Phase 2: Compiling ${resolverSourcePaths.length} resolvers at once...`);
    try {
      await this.compileAllResolvers();
    } catch (error: unknown) {
      const err = error as ExecError;
      logger.error(`Batch compilation failed: ${err.message || String(error)}`);
      for (const resolver of resolverSourcePaths) {
        failedResolvers.push({ file: resolver.relative, error: `Batch compilation failed: ${err.message || String(error)}` });
      }
    }

    // Phase 3: Read compiled files and save locally
    logger.debug("Phase 3: Reading compiled files and saving locally...");
    for (const resolver of resolverSourcePaths) {
      const resolverFileRelativePath = resolver.relative;
      const resolverAbsolutePath = resolver.absolute;

      try {
        const compiledJsPath = path.join(this.buildDir, "dist", resolverFileRelativePath.replace(".ts", ".js"));
        let jsContentWithHeader = await fsPromises.readFile(compiledJsPath, "utf-8");
        jsContentWithHeader = this.addHeaderToJs(jsContentWithHeader, resolverAbsolutePath);

        const localSavePath = path.join(localSavePathBase, resolverFileRelativePath.replace(".ts", ".js"));
        await this.saveCompiledFileLocally(localSavePath, jsContentWithHeader);

        compiledFilesRelative.push(resolverFileRelativePath.replace(".ts", ".js"));
        logger.success(`Compiled and saved ${path.basename(resolverFileRelativePath)}`);
      } catch (error: unknown) {
        const err = error as ExecError;
        logger.error(`Failed to read compiled resolver ${resolverFileRelativePath}: ${err.message || String(error)}`);
        failedResolvers.push({ file: resolverFileRelativePath, error: err.message || String(error) });
      }
    }

    // Compute build hash from compiled files
    logger.debug("Computing resolver build hash from compiled files...");
    let buildHash = "";
    try {
      const contents: string[] = [];
      compiledFilesRelative.sort();
      for (const relPath of compiledFilesRelative) {
        const localFile = path.join(localSavePathBase, relPath);
        const buf = await fsPromises.readFile(localFile, "utf-8");
        contents.push(buf);
      }
      const hasher = crypto.createHash("sha256");
      for (const c of contents) hasher.update(c);
      buildHash = hasher.digest("hex").slice(0, 16);
      logger.success(`Computed resolvers build hash: ${buildHash}`);
    } catch (err: unknown) {
      const error = err as ExecError;
      logger.error(`Error computing build hash: ${error.message || String(err)}`);
      throw err;
    }

    // Validate all compiled resolvers with AppSync
    logger.info("Validating resolvers with AppSync evaluate-code API...");
    const failedValidations: { file: string; error: string }[] = [];
    for (const relPath of compiledFilesRelative) {
      const localPath = path.join(localSavePathBase, relPath);
      try {
        const content = await fsPromises.readFile(localPath, "utf-8");
        await this.validateWithAppSync(content, relPath);
      } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        logger.error(`âœ— AppSync validation failed for ${relPath}: ${errorMessage}`);
        failedValidations.push({ file: relPath, error: errorMessage });
      }
    }

    if (failedValidations.length > 0) {
      logger.error(`\nâŒ AppSync Validation Failed:`);
      logger.error(`   ${failedValidations.length} resolver(s) failed validation:`);
      failedValidations.forEach(({ file, error }) => {
        logger.error(`     - ${file}: ${error}`);
      });
      throw new Error(`${failedValidations.length} resolver(s) failed AppSync validation. Fix the errors above and try again.`);
    }
    logger.success(`âœ“ All ${compiledFilesRelative.length} resolvers passed AppSync validation`);

    // Upload compiled files under hashed prefix
    const failedHashedUploads: { file: string; error: string }[] = [];
    for (const relPath of compiledFilesRelative) {
      const s3KeyHashed = path.posix.join(this.s3KeyPrefix, this.stage, buildHash, relPath);
      const localPath = path.join(localSavePathBase, relPath);
      try {
        const content = await fsPromises.readFile(localPath, "utf-8");
        await this.uploadToS3(s3KeyHashed, content, "application/javascript");
        logger.success(`âœ“ Uploaded resolver ${relPath} to s3://${this.s3BucketName}/${s3KeyHashed}`);
      } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        logger.error(`Failed to upload resolver ${relPath}: ${errorMessage}`);
        failedHashedUploads.push({ file: relPath, error: errorMessage });
      }
    }

    // Report summary
    logger.success(`\nðŸ“¦ Resolver Compilation Summary:`);
    logger.success(`   âœ“ Successfully compiled: ${compiledFilesRelative.length} resolvers`);

    if (failedResolvers.length > 0) {
      logger.error(`   âœ— Failed to compile: ${failedResolvers.length} resolvers`);
      failedResolvers.forEach(({ file, error }) => {
        logger.error(`     - ${file}: ${error}`);
      });
      throw new Error(`Failed to compile ${failedResolvers.length} resolver(s). Deployment cannot continue.`);
    }

    if (failedHashedUploads.length > 0) {
      logger.error(`Failed to upload ${failedHashedUploads.length} resolvers:`);
      failedHashedUploads.forEach(({ file, error }) => {
        logger.error(`  - ${file}: ${error}`);
      });
      throw new Error(`Failed to upload some resolver files.`);
    }

    logger.success("âœ“ All resolvers compiled and uploaded successfully.\n");
    logger.info(`Build hash: ${buildHash}`);

    // Clean up old resolver deployments from S3 (keep current + 1 previous for rollback)
    await this.cleanupOldS3Resolvers(2);

    return buildHash;
  }

  private async saveCompiledFileLocally(localPath: string, content: string): Promise<void> {
    try {
      await fsPromises.mkdir(path.dirname(localPath), { recursive: true });
      await fsPromises.writeFile(localPath, content);
      logger.debug(`Saved compiled file to ${localPath}`);
    } catch (error) {
      if (error instanceof Error) {
        logger.error(`Failed to save compiled file to ${localPath}: ${error.message}`);
      }
      throw error;
    }
  }

  private async setupBuildDirectory(): Promise<void> {
    logger.debug(`Setting up build directory: ${this.buildDir}`);
    await fsPromises.rm(this.buildDir, { recursive: true, force: true });
    await fsPromises.mkdir(this.buildDir, { recursive: true });

    await this.setupBuildConfiguration();

    // Try to symlink node_modules from project root
    const projectRoot = this.getProjectRoot();
    const rootNodeModules = path.join(projectRoot, "node_modules");
    const buildNodeModules = path.join(this.buildDir, "node_modules");

    if (fsNode.existsSync(rootNodeModules)) {
      try {
        await fsPromises.symlink(rootNodeModules, buildNodeModules, "junction");
        logger.success(`Symlinked node_modules from project root.`);
        return;
      } catch (symlinkError: unknown) {
        const err = symlinkError as ExecError;
        logger.warning(`Failed to symlink node_modules: ${err.message || String(symlinkError)}. Falling back to yarn install.`);
      }
    }

    // Fallback: yarn install
    try {
      execSync("yarn install --ignore-scripts --no-progress --non-interactive --prefer-offline", {
        cwd: this.buildDir,
        stdio: "pipe",
        encoding: "utf8",
      });
      logger.success(`Yarn install completed for build directory.`);
    } catch (error: unknown) {
      const err = error as ExecError;
      logger.error(`Yarn install failed: ${err.message || String(error)}`);
      throw error;
    }
  }

  private async setupBuildConfiguration(): Promise<void> {
    const packageJson = {
      name: "appsync-resolvers-build",
      version: "1.0.0",
      type: "module",
      private: true,
      dependencies: {
        "@aws-appsync/utils": "^1.1.1",
      },
      devDependencies: {
        typescript: "5.5.4",
        "@types/node": "^20.12.0",
      },
    };

    await fsPromises.writeFile(
      path.join(this.buildDir, "package.json"),
      JSON.stringify(packageJson, null, 2),
    );

    const tsConfig = {
      compilerOptions: {
        target: "ES2020",
        module: "ES6",
        moduleResolution: "node",
        outDir: "dist",
        rootDir: ".",
        removeComments: true,
        skipLibCheck: true,
        skipDefaultLibCheck: true,
        downlevelIteration: false,
        importHelpers: false,
        noEmitHelpers: true,
        strict: false,
        noImplicitAny: false,
      },
      include: ["**/*.ts"],
      exclude: ["node_modules", "dist", "**/__tests__", "**/*.test.ts", "**/*.spec.ts"],
    };

    await fsPromises.writeFile(
      path.join(this.buildDir, "tsconfig.json"),
      JSON.stringify(tsConfig, null, 2),
    );

    logger.debug("Created package.json and tsconfig.json in build directory");
  }

  /**
   * Prepares a resolver source file by inlining types and removing unsupported imports.
   */
  private async prepareSourceFile(
    originalResolverSourceCode: string,
    resolverAbsolutePath: string,
  ): Promise<void> {
    const resolverFileName = path.basename(resolverAbsolutePath);
    const resolverRelativePath = path.relative(this.baseResolverDir, resolverAbsolutePath);

    let codeToCompile = originalResolverSourceCode;

    // Check for 'gqlTypes' import and inline type definitions
    const gqlTypesImportRegex = /import\s+\{([^}]*)\}\s+from\s+(['"])[^'"]*gqlTypes[^'"]*\2;?\s*\n?/g;
    let gqlTypesMatch;
    const importedGqlTypes = new Set<string>();

    while ((gqlTypesMatch = gqlTypesImportRegex.exec(originalResolverSourceCode)) !== null) {
      const importedItems = gqlTypesMatch[1].split(",").map((item: string) => item.trim());
      importedItems.forEach((item: string) => {
        const cleanItem = item.replace(/^type\s+/, "").split(/\s+as\s+/)[0].trim();
        if (cleanItem) importedGqlTypes.add(cleanItem);
      });
    }

    if (importedGqlTypes.size > 0) {
      logger.debug(`Found gqlTypes imports in ${resolverFileName}: ${Array.from(importedGqlTypes).join(", ")}`);

      // Read gqlTypes from shared package
      const projectRoot = this.getProjectRoot();
      const gqlTypesSourcePath = path.join(projectRoot, "shared", "src", "types", "gqlTypes.ts");

      if (!fsNode.existsSync(gqlTypesSourcePath)) {
        throw new Error(`gqlTypes.ts not found at: ${gqlTypesSourcePath}. Please generate GraphQL types before deploying.`);
      }

      let gqlTypesContent = await fsPromises.readFile(gqlTypesSourcePath, "utf-8");

      // Transform TypeScript enums to const objects with type aliases
      gqlTypesContent = gqlTypesContent.replace(
        /(?:\/\*\*[\s\S]*?\*\/\s*)?export\s+enum\s+(\w+)\s*\{([^}]+)\}/g,
        (match, enumName, enumBody) => {
          const members = enumBody
            .split(",")
            .map((m: string) => m.trim())
            .filter((m: string) => m.length > 0)
            .map((m: string) => {
              const [key, value] = m.split("=").map((s: string) => s.trim());
              if (key && value) {
                return `  ${key}: ${value}`;
              }
              return null;
            })
            .filter((m: string | null): m is string => m !== null);

          return `const ${enumName} = {\n${members.join(",\n")}\n} as const;\ntype ${enumName} = (typeof ${enumName})[keyof typeof ${enumName}];`;
        },
      );

      // Remove all export keywords and imports
      let inlinedContent = "// Inlined types from gqlTypes.ts\n";
      inlinedContent += gqlTypesContent
        .replace(/^import\s+.*from\s+['"].*['"];?\s*$/gm, "")
        .replace(/^export\s+/gm, "")
        .trim();
      inlinedContent += "\n";

      logger.debug(`Inlined gqlTypes file for ${resolverFileName}`);

      // Replace gqlTypes imports with inlined content
      gqlTypesImportRegex.lastIndex = 0;
      codeToCompile = codeToCompile.replace(gqlTypesImportRegex, inlinedContent);
    }

    // Remove @aws-appsync/utils imports
    codeToCompile = codeToCompile.replace(
      /import\s*{\s*[^}]*\s*}\s*from\s*["']@aws-appsync\/utils["'];?\s*/g,
      "",
    );
    codeToCompile = codeToCompile.replace(
      /import\s*.*\s*from\s*["']@aws-appsync\/utils["'];?\s*/g,
      "",
    );

    // Add global declarations for AppSync runtime
    // Note: These use 'unknown' where possible, but some must remain loosely typed
    // because AppSync runtime injects these globals with dynamic shapes
    const appsyncGlobals = `// AppSync runtime globals (provided by AppSync, declared for TypeScript)
declare const util: {
  error: (message: string, errorType?: string, data?: unknown, errorInfo?: unknown) => never;
  appendError: (message: string, errorType?: string, data?: unknown, errorInfo?: unknown) => void;
  autoId: () => string;
  time: {
    nowISO8601: () => string;
    nowEpochSeconds: () => number;
    nowEpochMilliSeconds: () => number;
    nowFormatted: (format: string, timezone?: string) => string;
    parseFormattedToEpochMilliSeconds: (time: string, format: string, timezone?: string) => number;
    parseISO8601ToEpochMilliSeconds: (time: string) => number;
    epochMilliSecondsToSeconds: (epoch: number) => number;
    epochMilliSecondsToISO8601: (epoch: number) => string;
    epochMilliSecondsToFormatted: (epoch: number, format: string, timezone?: string) => string;
  };
  dynamodb: {
    toDynamoDB: (value: unknown) => Record<string, unknown>;
    toMapValues: (values: Record<string, unknown>) => Record<string, unknown>;
    toS3Object: (key: string, bucket: string, region: string, version?: string) => unknown;
  };
  transform: {
    toDynamoDBFilterExpression: (filter: unknown) => unknown;
  };
  str: {
    toUpper: (str: string) => string;
    toLower: (str: string) => string;
    toReplace: (str: string, substr: string, newSubstr: string) => string;
    normalize: (str: string, form: string) => string;
  };
  math: {
    roundNum: (num: number) => number;
    minVal: (nums: number[]) => number;
    maxVal: (nums: number[]) => number;
    randomDouble: () => number;
    randomWithSeed: (seed: number) => number;
  };
  authType: () => string;
};
declare const runtime: {
  earlyReturn: (result: unknown) => never;
};
interface ContextIdentity {
  sub: string;
  issuer: string;
  username: string;
  claims: Record<string, unknown>;
  sourceIp: string[];
  defaultAuthStrategy: string;
  groups: string[] | null;
}
type Context<TArguments = Record<string, unknown>, TSource = Record<string, unknown> | null, TStash = Record<string, unknown>, TResult = any, TReturns = unknown> = {
  arguments: TArguments;
  args: TArguments;
  source: TSource;
  result: TResult;
  prev: { result: TReturns } | null;
  stash: TStash;
  identity: ContextIdentity | null;
  request: { headers: Record<string, string>; domainName: string | null };
  info: { fieldName: string; parentTypeName: string; variables: Record<string, unknown>; selectionSetList: string[]; selectionSetGraphQL: string };
  env: Record<string, string>;
  error: { message: string; type: string } | null;
};
type AppSyncIdentityCognito = ContextIdentity;

`;
    codeToCompile = appsyncGlobals + codeToCompile;

    // Inject table name
    const tableName = `quiz-night-live-datatable-${this.stage}`;

    if (codeToCompile.includes("ctx.env.TABLE_NAME")) {
      codeToCompile = codeToCompile.replace(/ctx\.env\.TABLE_NAME/g, `"${tableName}"`);
      logger.info(`Injected table name "${tableName}" (ctx.env.TABLE_NAME) for ${resolverFileName}`);
    }

    if (codeToCompile.includes("__INJECTED_TABLE_NAME__")) {
      codeToCompile = codeToCompile.replace(/"__INJECTED_TABLE_NAME__"/g, `"${tableName}"`);
      codeToCompile = codeToCompile.replace(/__INJECTED_TABLE_NAME__/g, `"${tableName}"`);
      logger.info(`Injected table name "${tableName}" (__INJECTED_TABLE_NAME__) for ${resolverFileName}`);
    }

    // Write prepared source to build directory
    const tempResolverPath = path.join(this.buildDir, resolverRelativePath);
    await fsPromises.mkdir(path.dirname(tempResolverPath), { recursive: true });
    await fsPromises.writeFile(tempResolverPath, codeToCompile);
    logger.debug(`Wrote modified source ${resolverFileName} to ${tempResolverPath}`);
  }

  /**
   * Compiles all prepared resolver source files at once using TypeScript.
   */
  private async compileAllResolvers(): Promise<void> {
    logger.debug("Compiling all resolvers with TypeScript...");

    const distDir = path.join(this.buildDir, "dist");
    await fsPromises.mkdir(distDir, { recursive: true });

    try {
      const { exec } = await import("child_process");
      const { promisify } = await import("util");
      const execAsync = promisify(exec);

      const { stdout, stderr } = await execAsync(`npx tsc -p tsconfig.json`, { cwd: this.buildDir });

      if (stdout) logger.debug(`TypeScript compilation stdout: ${stdout}`);
      if (stderr) logger.debug(`TypeScript compilation stderr: ${stderr}`);

      logger.success("All resolvers compiled successfully");
    } catch (error: unknown) {
      const err = error as ExecError;
      logger.error(`TypeScript compilation failed: ${err.message || String(error)}`);
      if (err.stdout) logger.error(`Compilation stdout:\n${err.stdout.toString()}`);
      if (err.stderr) logger.error(`Compilation stderr:\n${err.stderr.toString()}`);
      throw error;
    }
  }
}

export { ResolverCompiler };
